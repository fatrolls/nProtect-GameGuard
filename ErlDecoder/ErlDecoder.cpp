// ErlDecoder.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>

/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <Wincrypt.h>
#include "defs.h"


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

#define RC4_INT unsigned char

typedef struct rc4_key_st {
    RC4_INT x, y;
    RC4_INT data[256];
} RC4_KEY;


class CFileAuthClient
{
public:
    HCRYPTPROV phProv = NULL;
    HCRYPTHASH  hHash;
    HCRYPTKEY   hKey;
    DWORD       len;
    u_int      buffsz;
    u_char* buff,
        * input,
        * output,
        * filename,
        * signature;

    u_int gg_filename_size;
    u_int totalSize;

    u_int retValue;

    BOOL sign_match;

    struct gameguard_header {
        u_int  sign1;
        u_int  filename_size;
        u_int  signature_size;
        u_int  sign2;
    } *gh = NULL;

    CFileAuthClient();
    ~CFileAuthClient();
    BOOL Auth(LPCSTR lpFileNameToRead, bool a3);
    BOOL Decrypt(LPCSTR lpFileNameRead, LPCSTR outputfileNameToCreate, BYTE* pbData, DWORD PubKeyLen);
    BOOL DecryptMem(LPCSTR lpFileName, char* dstArray, unsigned int dstSize, BYTE* pbData);
    BOOL DecryptRC4(unsigned __int8* buf, unsigned int size);
};

void __cdecl RC4_set_key(struct rc4_key_st*, int, unsigned __int8*); // idb
void __cdecl RC4(struct rc4_key_st*, unsigned int, unsigned __int8*, unsigned __int8*); // idb
// BOOL __stdcall CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptDestroyKey(HCRYPTKEY hKey);
// BOOL __stdcall CryptDestroyHash(HCRYPTHASH hHash);
// void __cdecl free(void *Block);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// char *__cdecl strrchr(const char *Str, int Ch);
// BOOL __stdcall CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags);
// BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// DWORD __stdcall GetLastError();
// BOOL __stdcall CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// void *__cdecl malloc(size_t Size);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// BOOL __stdcall CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);

//-------------------------------------------------------------------------
// Data declarations

BYTE pbPubKey[] =
{
  6u,
  2u,
  0u,
  0u,
  0u,
  36u,
  0u,
  0u,
  82u,
  83u,
  65u,
  49u,
  0u,
  2u,
  0u,
  0u,
  1u,
  0u,
  1u,
  0u,
  251u,
  227u,
  252u,
  9u,
  175u,
  174u,
  101u,
  140u,
  150u,
  76u,
  197u,
  55u,
  210u,
  164u,
  119u,
  231u,
  76u,
  65u,
  194u,
  207u,
  242u,
  254u,
  45u,
  156u,
  128u,
  148u,
  12u,
  136u,
  109u,
  179u,
  132u,
  159u,
  140u,
  34u,
  160u,
  201u,
  205u,
  192u,
  171u,
  48u,
  101u,
  130u,
  66u,
  60u,
  238u,
  60u,
  168u,
  183u,
  17u,
  214u,
  34u,
  250u,
  251u,
  35u,
  247u,
  114u,
  205u,
  231u,
  208u,
  111u,
  106u,
  142u,
  150u,
  227u
};

DWORD dwPubKeyLen = 84u; // idb

//dwPubKeyLen = 84 too.
BYTE KEY2[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31,
    0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x91, 0xc8, 0xb0, 0x9a,
    0x2c, 0x39, 0xd2, 0x73, 0x5e, 0x8f, 0x6f, 0x15, 0x2a, 0xe7, 0x4f, 0xbd,
    0x66, 0xff, 0x4e, 0x8d, 0x8c, 0xb3, 0xc0, 0x8d, 0x98, 0xf4, 0xb2, 0xdc,
    0x81, 0x43, 0x51, 0xbc, 0xf3, 0xd6, 0x74, 0x50, 0x7f, 0x39, 0x87, 0xa8,
    0x1b, 0x5c, 0x06, 0x36, 0x47, 0x08, 0xa8, 0xd8, 0x63, 0xad, 0xfd, 0x6d,
    0xb5, 0xa4, 0x94, 0xf0, 0xe0, 0xdf, 0xea, 0xc5, 0xf4, 0x73, 0xdc, 0xd2
};
DWORD dwPubKeyLen_Key2 = 84;

//dwPubKeyLen = 276
BYTE KEY3[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31,
    0x00, 0x08, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x11, 0x1c, 0x30, 0x49,
    0x7a, 0x1d, 0x09, 0xfa, 0x1c, 0xb0, 0x45, 0x9d, 0xee, 0x2d, 0xc8, 0x00,
    0xd1, 0x90, 0xfb, 0x1c, 0x1a, 0xa8, 0x00, 0x81, 0x13, 0x15, 0xa5, 0xa8,
    0x7d, 0x30, 0xfb, 0x7f, 0x47, 0xf0, 0x83, 0x01, 0xe7, 0xc1, 0x45, 0xb2,
    0xfa, 0x98, 0x01, 0x3f, 0xea, 0x04, 0xb9, 0xd3, 0xc5, 0x24, 0x93, 0xa3,
    0x7e, 0x90, 0x31, 0xa6, 0xec, 0x87, 0xec, 0x2b, 0x2a, 0xab, 0x95, 0xa5,
    0x3e, 0xbd, 0x99, 0xc2, 0x0c, 0x6e, 0x4e, 0x08, 0x40, 0xa6, 0xd6, 0x73,
    0x64, 0xad, 0xb6, 0x32, 0x99, 0x64, 0x2a, 0xf2, 0x24, 0xa5, 0x21, 0xd8,
    0x63, 0xe1, 0xbe, 0xcd, 0xcd, 0x66, 0x4c, 0xe5, 0x6a, 0x4d, 0xd1, 0xd1,
    0x44, 0xb0, 0x5d, 0xd3, 0xd6, 0x94, 0xac, 0x29, 0x66, 0x25, 0x24, 0x19,
    0xef, 0x12, 0x88, 0xad, 0x74, 0xd6, 0x42, 0xb6, 0x93, 0x9b, 0x82, 0xbd,
    0x01, 0x32, 0x6b, 0x5b, 0xb5, 0xbf, 0xfd, 0x04, 0x00, 0xba, 0x52, 0xf8,
    0x59, 0x9a, 0xd9, 0x7d, 0xaa, 0xb9, 0xd2, 0x74, 0x12, 0x94, 0x06, 0x9b,
    0x4e, 0xdb, 0x3b, 0x97, 0x25, 0x01, 0x1a, 0xe5, 0xf8, 0x4b, 0xe4, 0xe0,
    0xae, 0xae, 0xfe, 0x2a, 0x24, 0x9e, 0x46, 0xbd, 0xc3, 0xc5, 0xa2, 0x67,
    0x5d, 0x89, 0x9f, 0xa5, 0xeb, 0x60, 0x1e, 0xb6, 0x41, 0x88, 0xb0, 0x95,
    0xa1, 0x45, 0xc4, 0x5e, 0xa1, 0x3f, 0xc2, 0xed, 0x18, 0xf1, 0x64, 0xdd,
    0x4c, 0xea, 0x17, 0xe3, 0x3a, 0x26, 0x32, 0x01, 0xe3, 0xe3, 0xba, 0x4c,
    0xb5, 0x82, 0x19, 0x93, 0xff, 0x53, 0x7c, 0x03, 0x6c, 0xc5, 0x04, 0x8a,
    0x9c, 0x01, 0xfc, 0x83, 0x58, 0x28, 0x1f, 0xa5, 0xc1, 0x63, 0x96, 0x75,
    0x84, 0xf3, 0xdd, 0xab, 0x86, 0xbb, 0xff, 0xcf, 0xce, 0x62, 0x85, 0x9c, 
    0xd1, 0x07, 0xd1, 0x5a, 0xf8, 0x07, 0xc4, 0x64, 0x8f, 0x20, 0xce, 0xc2
};
DWORD dwPubKeyLen_Key3 = 276;

DWORD WhichKeyUsed = 0;

//----- (00000058) --------------------------------------------------------
CFileAuthClient::CFileAuthClient()
{
    if (!CryptAcquireContext(&phProv, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        phProv = 0;
}

//----- (000000D4) --------------------------------------------------------
CFileAuthClient::~CFileAuthClient()
{
    HCRYPTHASH v2; // eax
    void(__stdcall * v3)(HCRYPTHASH); // ebx
    HCRYPTKEY v4; // eax
    void(__stdcall * v5)(HCRYPTKEY); // edi
    HCRYPTPROV v6; // esi

    if (*((_DWORD*)buff))
        free(*((void**)buff));
    if (*((_DWORD*)signature))
        free(*((void**)signature));

    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);

    if (hKey)
        CryptDestroyKey(hKey);
    if (hHash)
        CryptDestroyHash(hHash);

    if (phProv)
        CryptReleaseContext(phProv, 0);
}

//----- (00000144) --------------------------------------------------------
BOOL CFileAuthClient::Auth(LPCSTR lpFileNameToRead, bool a3)
{
    char result; // al
    HANDLE v5; // eax
    void* v6; // esi
    DWORD v7; // eax
    void* v8; // eax
    HCRYPTPROV v9; // eax
    uint32* v10; // edx
    uint32 v11; // ecx
    uint32 v12; // edx
    int v13; // edx
    void* v14; // eax
    void* v15; // eax
    HCRYPTPROV* v16; // edi
    BOOL(__stdcall * v17)(HCRYPTPROV, const BYTE*, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY*); // esi
    HCRYPTPROV* v18; // esi
    char* v19; // eax
    const char* v20; // eax
    DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

    if (!lpFileNameToRead)
    {
        retValue = 1;
        return 0;
    }
    if (!*lpFileNameToRead)
    {
        retValue = 2;
        return 0;
    }
    v5 = CreateFile(lpFileNameToRead, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
    v6 = v5;
    if (v5 == (HANDLE)-1)
    {
        retValue = 3;
        return 0;
    }
    v7 = GetFileSize(v5, 0);
    buffsz = v7;
    if (v7 == -1)
    {
        CloseHandle(v6);
        retValue = 33;
        return 0;
    }

    if (buff)
    {
        free(buff);
        buff = 0;
    }

    buff = (uchar*) malloc(buffsz);

    if (!buff)
    {
        CloseHandle(v6);
        retValue = 4;
        return 0;
    }
    ReadFile(v6, buff, buffsz, &NumberOfBytesRead, 0);

    if (NumberOfBytesRead != buffsz)
    {
        CloseHandle(v6);
        retValue = 5;
        return 0;
    }

    v10 = (_DWORD*)(buff + buffsz - 16);
    gh = new struct gameguard_header;

    gh->sign1 = *v10;
    gh->filename_size = v10[1];
    gh->signature_size = v10[2];
    gh->sign2 = v10[3];
    if (gh->sign1 == 0x32812622 && gh->sign2 == 847324705)
    {
        v11 = gh->filename_size;
        v12 = gh->signature_size;
        sign_match = 1;
        v13 = v12 + v11 + 16;
        gg_filename_size = v11;
        totalSize = v13;
        len = buffsz - v13;
    }
    else
    {
        gh->sign1 = 0;
        gh->filename_size = 0;
        gh->signature_size = 0;
        gh->sign2 = 0;
        v9 = buffsz;
        sign_match = 0;
        totalSize = 0;
        len = buffsz;
        gg_filename_size = 0;
    }
    if (buffsz < totalSize)
    {
        sign_match = 0;
        totalSize = 0;
        buffsz = 0;
        len = 0;
        gg_filename_size = 0;
    }
    CloseHandle(v6);
    if (!sign_match)
    {
        retValue = 6;
        return 0;
    }
    v14 = (void*)signature;
    gh->signature_size = gh->signature_size;
    if (v14)
    {
        free(v14);
        signature = 0;
    }
    v15 = malloc(gh->signature_size);
    signature = (uchar*)v15;
    if (!v15)
    {
        retValue = 7;
        return 0;
    }
    qmemcpy(v15, (const void*)(gg_filename_size + buff + len), gh->signature_size);
    if (!phProv && !CryptAcquireContext(&phProv, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        retValue = 8;
        return 0;
    }

    if (hKey)
    {
        CryptDestroyKey(hKey);
        hKey = 0;
    }
    if (!CryptImportKey(phProv, pbPubKey, dwPubKeyLen, 0, 0, &hKey))
    {
        if (GetLastError() != 87)
            goto LABEL_37;
        if (!CryptAcquireContext(&phProv, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            retValue = 98;
            return 0;
        }
        if (!CryptImportKey(phProv, pbPubKey, dwPubKeyLen, 0, 0, &hKey))
        {
        LABEL_37:
            retValue = 9;
            return 0;
        }
    }

    if (hHash)
    {
        CryptDestroyHash(hHash);
        hHash = 0;
    }
    if (!CryptCreateHash(phProv, CALG_MD5, 0, 0, &hHash))
    {
        retValue = 10;
        return 0;
    }
    if (!CryptHashData(hHash, (const BYTE*)buff, gg_filename_size + len, 0))
    {
        retValue = 11;
        return 0;
    }

    if (CryptVerifySignature(hHash, (const BYTE*)signature, gh->signature_size, hKey, 0, 0))
        goto LABEL_61;

    if (GetLastError() != 87)
        goto LABEL_49;

    if (!CryptAcquireContext(&phProv, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        retValue = 128;
        return 0;
    }

    if (CryptVerifySignature(hHash, (const BYTE*)signature, gh->signature_size, hKey, 0, 0))
    {
    LABEL_61:
        if (!a3
            || ((v19 = (char*)strrchr(lpFileNameToRead, '\\')) == 0 ? (v20 = lpFileNameToRead) : (v20 = v19 + 1),
                !_strnicmp(v20, (const char*)(buff + len), gg_filename_size)))
        {
            if (buff)
            {
                free(buff);
                buff = 0;
            }
            result = 1;
        }
        else
        {
            retValue = 13;
            result = 0;
        }
    }
    else
    {
    LABEL_49:
        retValue = 12;
        result = 0;
    }
    return result;
}

//----- (00000554) --------------------------------------------------------
BOOL CFileAuthClient::Decrypt(LPCSTR lpFileNameRead, LPCSTR outputfileNameToCreate, BYTE* pbData, DWORD PubKeyLen = 0)
{
    HANDLE v5; // eax
    void* v6; // edi
    char result; // al
    DWORD v8; // eax
    void* v9; // eax
    unsigned int v10; // eax
    _DWORD* v11; // edx
    int v12; // ecx
    int v13; // edx
    int v14; // edx
    HCRYPTHASH* v15; // ebp
    HCRYPTKEY* v16; // edi
    BYTE* v17; // ecx
    HANDLE v18; // edi
    DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

    v5 = CreateFile(lpFileNameRead, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
    v6 = v5;
    if (v5 == (HANDLE)-1)
    {
        retValue = 1;
        return 0;
    }
    v8 = GetFileSize(v5, 0);
    buffsz = v8;
    if (v8 == -1)
    {
        CloseHandle(v6);
        retValue = 11;
        return 0;
    }
    if (buff)
    {
        free(buff);
        buff = 0;
    }
    buff = (uchar*) malloc(buffsz);

    if (!buff)
    {
        CloseHandle(v6);
        retValue = 2;
        return 0;
    }
    ReadFile(v6, buff, buffsz, &NumberOfBytesRead, 0);

    if (NumberOfBytesRead != buffsz)
    {
        CloseHandle(v6);
        retValue = 3;
        return 0;
    }
    v11 = (_DWORD*)(buff + buffsz - 16); //buff / struct to gh.
    
    gh = new struct gameguard_header;

    gh->sign1 = *v11; //sign1
    gh->filename_size = v11[1]; //filenamesize
    gh->signature_size = v11[2]; //signature+size
    gh->sign2 = v11[3]; //sign2


    if (gh->sign1 == 847324706 && gh->sign2 == 847324705)
    {
        v12 = gh->filename_size;
        v13 = gh->signature_size;
        sign_match = 1;
        v14 = v13 + v12 + 16;
        gg_filename_size = v12;
        totalSize = v14;
        len = buffsz - v14;
    }
    else
    {
        gh->sign1 = 0;
        gh->filename_size = 0;
        gh->signature_size = 0;
        gh->sign2 = 0;
        v10 = buffsz;
        sign_match = 0;
        totalSize = 0;
        len = buffsz;
        gg_filename_size = 0;
    }
    if (buffsz < totalSize)
    {
        sign_match = 0;
        totalSize = 0;
        buffsz = 0;
        len = 0;
        gg_filename_size = 0;
    }
    CloseHandle(v6);
    if (!*(_DWORD*)phProv
        && !CryptAcquireContext(
            &phProv,
            0,
            MS_DEF_PROV,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
        retValue = 4;
        return 0;
    }

    if (hHash)
    {
        CryptDestroyHash(hHash);
        hHash = 0;
    }

    if (!CryptCreateHash(phProv, CALG_MD5, 0, 0, &hHash))
    {
        retValue = 5;
        return 0;
    }

    if (PubKeyLen == 0) {

        if (!CryptHashData(hHash, pbData, strlen((const char*)pbData), 0))
        {
            retValue = 6;
            return 0;
        }
    } else {
        if (!CryptHashData(hHash, pbData, PubKeyLen, 0))
        {
            retValue = 6;
            return 0;
        }
    }

    if (hKey)
    {
        CryptDestroyKey(hKey);
        hKey = 0;
    }

    if (!CryptDeriveKey(phProv, CALG_RC4, hHash, 0, &hKey))
    {
        retValue = 7;
        return 0;
    }

    if (CryptDecrypt(hKey, 0, 1, 0, buff, &len))
        goto LABEL_35;

    if (GetLastError() != (unsigned int)NTE_PERM)
    {
        retValue = 8;
        return 0;
    }
    result = CFileAuthClient::DecryptRC4(*((unsigned __int8**)buff), len);
    if (result)
    {
    LABEL_35:
        v18 = CreateFile(outputfileNameToCreate, GENERIC_WRITE, 3u, 0, 2u, 0x80u, 0);
        if (v18 == (HANDLE)-1)
        {
            retValue = 9;
            result = 0;
        }
        else
        {
            WriteFile(v18, buff, len, (LPDWORD)&len, 0);
            SetEndOfFile(v18);
            FlushFileBuffers(v18);
            CloseHandle(v18);
            if (buff)
            {
                free(buff);
                buff = 0;
            }
            result = 1;
        }
    }
    else
    {
        retValue = 88;
    }
    return result;
}

//----- (00000874) --------------------------------------------------------
BOOL CFileAuthClient::DecryptMem(LPCSTR lpFileName, char* dstArray, unsigned int dstSize, BYTE* pbData)
{
    HANDLE v6; // eax
    void* v7; // esi
    char result; // al
    DWORD v9; // eax
    void* v10; // eax
    unsigned int v11; // eax
    _DWORD* v12; // edx
    int v13; // ecx
    int v14; // edx
    int v15; // edx
    HCRYPTHASH* v16; // ebx
    HCRYPTKEY* v17; // esi
    BYTE* v18; // ecx
    unsigned int v19; // eax
    char* v20; // edx
    DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

    v6 = CreateFile(lpFileName, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
    v7 = v6;
    if (v6 == (HANDLE)-1)
    {
        retValue = 1;
        return 0;
    }
    v9 = GetFileSize(v6, 0);
    buffsz = v9;
    if (v9 == -1)
    {
        CloseHandle(v7);
        retValue = 11;
        return 0;
    }
    if (*((_DWORD*)buff))
    {
        free(*((void**)buff));
        *((_DWORD*)buff) = 0;
    }
    buff = (uchar*) malloc(buffsz);

    if (!buff)
    {
        CloseHandle(v7);
        retValue = 2;
        return 0;
    }

    ReadFile(v7, buff, buffsz, &NumberOfBytesRead, 0);

    if (NumberOfBytesRead != buffsz)
    {
        CloseHandle(v7);
        retValue = 3;
        return 0;
    }
    v12 = (_DWORD*)(buff + buffsz - 16); //buff / struct to gh.
    
    gh = new struct gameguard_header;

    gh->sign1 = *v12;
    gh->filename_size = v12[1];
    gh->signature_size = v12[2];
    gh->sign2 = v12[3];
    if (gh->sign1 == 847324706 && gh->sign2 == 847324705)
    {
        v13 = gh->filename_size;
        v14 = gh->signature_size;
        sign_match = 1;
        v15 = v14 + v13 + 16;
        gg_filename_size = v13;
        totalSize = v15;
        len = buffsz - v15;
    }
    else
    {
        gh->sign1 = 0;
        gh->filename_size = 0;
        gh->signature_size = 0;
        gh->sign2 = 0;
        sign_match = 0;
        v11 = buffsz;
        totalSize = 0;
        len = buffsz;
        gg_filename_size = 0;
    }
    if (buffsz < totalSize)
    {
        sign_match = 0;
        totalSize = 0;
        buffsz = 0;
        len = 0;
        gg_filename_size = 0;
    }
    
    CloseHandle(v7);

    if (!*(_DWORD*)phProv
        && !CryptAcquireContext(&phProv, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        retValue = 4;
        return 0;
    }

    if (hHash)
    {
        CryptDestroyHash(hHash);
        hHash = 0;
    }

    if (!CryptCreateHash(phProv, CALG_MD5, 0, 0, &hHash))
    {
        retValue = 5;
        return 0;
    }

    if (!CryptHashData(hHash, pbData, strlen((const char*)pbData), 0))
    {
        retValue = 6;
        return 0;
    }

    if (hKey)
    {
        CryptDestroyKey(hKey);
        hKey = 0;
    }

    if (!CryptDeriveKey(phProv, CALG_RC4, hHash, 0, &hKey))
    {
        retValue = 7;
        return 0;
    }

    if (CryptDecrypt(hKey, 0, 1, 0, buff, (DWORD*)&len))
        goto LABEL_35;

    if (GetLastError() != (unsigned int)NTE_PERM)
    {
        retValue = 8;
        return 0;
    }

    result = CFileAuthClient::DecryptRC4(*((unsigned __int8**)buff), (unsigned int)len);
    
    if (result)
    {
    LABEL_35:
        v19 = dstSize;
        if (dstSize > len)
            v19 = len;
        v20 = dstArray;
        qmemcpy(dstArray, *((const void**)buff), v19);
        v20[v19] = 0;
        if (*((_DWORD*)buff))
        {
            free(*((void**)buff));
            *((_DWORD*)buff) = 0;
        }
        result = 1;
    }
    else
    {
        retValue = 88;
    }
    return result;
}

//----- (00000B74) --------------------------------------------------------
void __cdecl RC4_set_key(struct rc4_key_st* key, int pdwDataLen, unsigned __int8* pbData)
{
    char* v3; // esi
    char v4; // di
    unsigned int v5; // eax
    _DWORD* v6; // ecx
    int v7; // eax
    int* v8; // ecx
    int v9; // edx
    int v10; // ebx
    int v11; // eax
    int v12; // edx
    int v13; // ebx
    int v14; // eax
    int v15; // edx
    int v16; // ebx
    int v17; // eax
    int v18; // edx
    int v19; // ebx
    struct rc4_key_st* keya; // [esp+14h] [ebp+4h]

    v3 = (char*)key + 8;
    v4 = 0;
    v5 = 0;
    v6 = (_DWORD*)((char*)key + 8);
    do
        *v6++ = v5++;
    while (v5 < 0x100);
    *(_DWORD*)key = 0;
    *((_DWORD*)key + 1) = 0;
    v7 = 0;
    v8 = (int*)((char*)key + 16);
    keya = (struct rc4_key_st*)(&pbPubKey + 64);
    do
    {
        v9 = *(v8 - 2);
        v10 = (unsigned __int8)(v4 + v9 + pbData[v7]);
        v11 = v7 + 1;
        if (v11 == pdwDataLen)
            v11 = 0;
        *(v8 - 2) = *(_DWORD*)&v3[4 * v10];
        *(_DWORD*)&v3[4 * v10] = v9;
        v12 = *(v8 - 1);
        v13 = (unsigned __int8)(v10 + v12 + pbData[v11]);
        v14 = v11 + 1;
        if (v14 == pdwDataLen)
            v14 = 0;
        *(v8 - 1) = *(_DWORD*)&v3[4 * v13];
        *(_DWORD*)&v3[4 * v13] = v12;
        v15 = *v8;
        v16 = (unsigned __int8)(v13 + *v8 + pbData[v14]);
        v17 = v14 + 1;
        if (v17 == pdwDataLen)
            v17 = 0;
        *v8 = *(_DWORD*)&v3[4 * v16];
        *(_DWORD*)&v3[4 * v16] = v15;
        v18 = v8[1];
        v19 = (unsigned __int8)(v16 + v18 + pbData[v17]);
        v7 = v17 + 1;
        v4 = v19;
        if (v7 == pdwDataLen)
            v7 = 0;
        v8[1] = *(_DWORD*)&v3[4 * v19];
        *(_DWORD*)&v3[4 * v19] = v18;
        v8 += 4;
        keya = (struct rc4_key_st*)((char*)keya - 1);
    } while (keya);
}

//----- (00000C64) --------------------------------------------------------
void __cdecl RC4(struct rc4_key_st* rc4_key, unsigned int size, unsigned __int8* buf, unsigned __int8* buf_)
{
    char v4; // dl
    int v6; // ebp
    int v7; // edi
    int v8; // edi
    int v9; // ecx
    int v10; // ebp
    int v11; // edx
    int v12; // edi
    int v13; // edx
    int v14; // ebp
    int v15; // ebx
    int v16; // edi
    int v17; // edx
    int v18; // ebp
    int v19; // ebx
    int v20; // edi
    int v21; // edx
    int v22; // ebp
    int v23; // ebx
    int v24; // edi
    int v25; // edx
    int v26; // ebp
    int v27; // ebx
    int v28; // edi
    int v29; // edx
    int v30; // ebp
    int v31; // ebx
    int v32; // edi
    int v33; // edx
    int v34; // ebp
    int v35; // ebx
    int v36; // edx
    int v37; // ebx
    unsigned __int8* v38; // ecx
    unsigned __int8* v39; // esi
    int v40; // edi
    int v41; // edx
    int v42; // ebp
    int v43; // ebx
    _BYTE* v44; // ecx
    _BYTE* v45; // esi
    int v46; // edi
    int v47; // edx
    int v48; // ebp
    int v49; // ebx
    int v50; // edi
    int v51; // edx
    int v52; // ebp
    int v53; // ebx
    int v54; // edi
    int v55; // edx
    int v56; // ebp
    int v57; // ebx
    int v58; // edi
    int v59; // edx
    int v60; // ebp
    int v61; // ebx
    int v62; // edi
    int v63; // edx
    int v64; // ebp
    int v65; // ebx
    int v66; // edi
    int v67; // edx
    int v68; // ebp
    int v69; // ebx
    int v70; // edx
    int v71; // ebx
    int v72; // edx
    int v73; // ebx
    _BYTE* v74; // ecx
    _BYTE* v75; // esi
    int v76; // edx
    int v77; // ebx
    _BYTE* v78; // ecx
    _BYTE* v79; // esi
    int v80; // edx
    int v81; // ebx
    _BYTE* v82; // ecx
    _BYTE* v83; // esi
    int v84; // edx
    int v85; // ebx
    _BYTE* v86; // ecx
    _BYTE* v87; // esi
    int v88; // edx
    int v89; // ebx
    _BYTE* v90; // ecx
    _BYTE* v91; // esi
    int v92; // edx
    int v93; // ebx
    _BYTE* v94; // ecx
    _BYTE* v95; // esi
    int v96; // edx
    int v97; // ebx
    _BYTE* v98; // ecx
    _BYTE* v99; // esi
    int v100; // edx
    int v101; // ebx
    struct rc4_key_st* rc4_keya; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyb; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyc; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyd; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keye; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyf; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyg; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyh; // [esp+14h] [ebp+4h]
    struct rc4_key_st* rc4_keyi; // [esp+14h] [ebp+4h]
    unsigned __int8* buf_a; // [esp+20h] [ebp+10h]

    v4 = size;
    v6 = *((_DWORD*)rc4_key + 1);
    v7 = *(_DWORD*)rc4_key;
    rc4_keya = (struct rc4_key_st*)(size >> 3);
    if (size >> 3)
    {
        v8 = (unsigned __int8)(v7 + 1);
        v9 = *((_DWORD*)rc4_key + v8 + 2);
        v10 = (unsigned __int8)(v9 + v6);
        v11 = *((_DWORD*)rc4_key + v10 + 2);
        *((_DWORD*)rc4_key + v8 + 2) = v11;
        *((_DWORD*)rc4_key + v10 + 2) = v9;
        *buf_ = *buf ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v9 + v11) + 8);
        v12 = (unsigned __int8)(v8 + 1);
        v13 = *((_DWORD*)rc4_key + v12 + 2);
        v14 = (unsigned __int8)(v13 + v10);
        v15 = *((_DWORD*)rc4_key + v14 + 2);
        *((_DWORD*)rc4_key + v12 + 2) = v15;
        *((_DWORD*)rc4_key + v14 + 2) = v13;
        buf_[1] = buf[1] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v13 + v15) + 8);
        v16 = (unsigned __int8)(v12 + 1);
        v17 = *((_DWORD*)rc4_key + v16 + 2);
        v18 = (unsigned __int8)(v17 + v14);
        v19 = *((_DWORD*)rc4_key + v18 + 2);
        *((_DWORD*)rc4_key + v16 + 2) = v19;
        *((_DWORD*)rc4_key + v18 + 2) = v17;
        buf_[2] = buf[2] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v17 + v19) + 8);
        v20 = (unsigned __int8)(v16 + 1);
        v21 = *((_DWORD*)rc4_key + v20 + 2);
        v22 = (unsigned __int8)(v21 + v18);
        v23 = *((_DWORD*)rc4_key + v22 + 2);
        *((_DWORD*)rc4_key + v20 + 2) = v23;
        *((_DWORD*)rc4_key + v22 + 2) = v21;
        buf_[3] = buf[3] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v21 + v23) + 8);
        v24 = (unsigned __int8)(v20 + 1);
        v25 = *((_DWORD*)rc4_key + v24 + 2);
        v26 = (unsigned __int8)(v25 + v22);
        v27 = *((_DWORD*)rc4_key + v26 + 2);
        *((_DWORD*)rc4_key + v24 + 2) = v27;
        *((_DWORD*)rc4_key + v26 + 2) = v25;
        buf_[4] = buf[4] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v25 + v27) + 8);
        v28 = (unsigned __int8)(v24 + 1);
        v29 = *((_DWORD*)rc4_key + v28 + 2);
        v30 = (unsigned __int8)(v29 + v26);
        v31 = *((_DWORD*)rc4_key + v30 + 2);
        *((_DWORD*)rc4_key + v28 + 2) = v31;
        *((_DWORD*)rc4_key + v30 + 2) = v29;
        buf_[5] = buf[5] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v29 + v31) + 8);
        v32 = (unsigned __int8)(v28 + 1);
        v33 = *((_DWORD*)rc4_key + v32 + 2);
        v34 = (unsigned __int8)(v33 + v30);
        v35 = *((_DWORD*)rc4_key + v34 + 2);
        *((_DWORD*)rc4_key + v32 + 2) = v35;
        *((_DWORD*)rc4_key + v34 + 2) = v33;
        buf_[6] = buf[6] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v33 + v35) + 8);
        v7 = (unsigned __int8)(v32 + 1);
        v36 = *((_DWORD*)rc4_key + v7 + 2);
        v6 = (unsigned __int8)(v36 + v34);
        v37 = *((_DWORD*)rc4_key + v6 + 2);
        *((_DWORD*)rc4_key + v7 + 2) = v37;
        *((_DWORD*)rc4_key + v6 + 2) = v36;
        buf_[7] = buf[7] ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v36 + v37) + 8);
        v38 = buf_ + 8;
        v39 = buf + 8;
        if (rc4_keya != (struct rc4_key_st*)&pbPubKey[1])
        {
            buf_a = (unsigned __int8*)rc4_keya - 1;
            do
            {
                v40 = (unsigned __int8)(v7 + 1);
                v41 = *((_DWORD*)rc4_key + v40 + 2);
                v42 = (unsigned __int8)(v41 + v6);
                v43 = *((_DWORD*)rc4_key + v42 + 2);
                *((_DWORD*)rc4_key + v40 + 2) = v43;
                *((_DWORD*)rc4_key + v42 + 2) = v41;
                *v38 = *v39 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v41 + v43) + 8);
                v44 = v38 + 1;
                v45 = v39 + 1;
                v46 = (unsigned __int8)(v40 + 1);
                v47 = *((_DWORD*)rc4_key + v46 + 2);
                v48 = (unsigned __int8)(v47 + v42);
                v49 = *((_DWORD*)rc4_key + v48 + 2);
                *((_DWORD*)rc4_key + v46 + 2) = v49;
                *((_DWORD*)rc4_key + v48 + 2) = v47;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v47 + v49) + 8);
                v50 = (unsigned __int8)(v46 + 1);
                v51 = *((_DWORD*)rc4_key + v50 + 2);
                v52 = (unsigned __int8)(v51 + v48);
                v53 = *((_DWORD*)rc4_key + v52 + 2);
                *((_DWORD*)rc4_key + v50 + 2) = v53;
                *((_DWORD*)rc4_key + v52 + 2) = v51;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v51 + v53) + 8);
                v54 = (unsigned __int8)(v50 + 1);
                v55 = *((_DWORD*)rc4_key + v54 + 2);
                v56 = (unsigned __int8)(v55 + v52);
                v57 = *((_DWORD*)rc4_key + v56 + 2);
                *((_DWORD*)rc4_key + v54 + 2) = v57;
                *((_DWORD*)rc4_key + v56 + 2) = v55;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v55 + v57) + 8);
                v58 = (unsigned __int8)(v54 + 1);
                v59 = *((_DWORD*)rc4_key + v58 + 2);
                v60 = (unsigned __int8)(v59 + v56);
                v61 = *((_DWORD*)rc4_key + v60 + 2);
                *((_DWORD*)rc4_key + v58 + 2) = v61;
                *((_DWORD*)rc4_key + v60 + 2) = v59;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v59 + v61) + 8);
                v62 = (unsigned __int8)(v58 + 1);
                v63 = *((_DWORD*)rc4_key + v62 + 2);
                v64 = (unsigned __int8)(v63 + v60);
                v65 = *((_DWORD*)rc4_key + v64 + 2);
                *((_DWORD*)rc4_key + v62 + 2) = v65;
                *((_DWORD*)rc4_key + v64 + 2) = v63;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v63 + v65) + 8);
                v66 = (unsigned __int8)(v62 + 1);
                v67 = *((_DWORD*)rc4_key + v66 + 2);
                v68 = (unsigned __int8)(v67 + v64);
                v69 = *((_DWORD*)rc4_key + v68 + 2);
                *((_DWORD*)rc4_key + v66 + 2) = v69;
                *((_DWORD*)rc4_key + v68 + 2) = v67;
                *v44++ = *v45++ ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v67 + v69) + 8);
                v7 = (unsigned __int8)(v66 + 1);
                v70 = *((_DWORD*)rc4_key + v7 + 2);
                v6 = (unsigned __int8)(v70 + v68);
                v71 = *((_DWORD*)rc4_key + v6 + 2);
                *((_DWORD*)rc4_key + v7 + 2) = v71;
                *((_DWORD*)rc4_key + v6 + 2) = v70;
                *v44 = *v45 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v70 + v71) + 8);
                v38 = v44 + 1;
                v39 = v45 + 1;
                --buf_a;
            } while (buf_a);
        }
        v4 = size;
    }
    else
    {
        v38 = buf_;
        v39 = buf;
    }
    rc4_keyb = (struct rc4_key_st*)(v4 & 7);
    if ((v4 & 7) != 0)
    {
        v7 = (unsigned __int8)(v7 + 1);
        v72 = *((_DWORD*)rc4_key + v7 + 2);
        v6 = (unsigned __int8)(v72 + v6);
        v73 = *((_DWORD*)rc4_key + v6 + 2);
        *((_DWORD*)rc4_key + v7 + 2) = v73;
        *((_DWORD*)rc4_key + v6 + 2) = v72;
        *v38 = *v39 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v72 + v73) + 8);
        v74 = v38 + 1;
        v75 = v39 + 1;
        for (rc4_keyc = (struct rc4_key_st*)((char*)rc4_keyb - 1);
            rc4_keyc;
            rc4_keyc = (struct rc4_key_st*)((char*)rc4_keyi - 1))
        {
            v7 = (unsigned __int8)(v7 + 1);
            v76 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v76 + v6);
            v77 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v77;
            *((_DWORD*)rc4_key + v6 + 2) = v76;
            *v74 = *v75 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v76 + v77) + 8);
            v78 = v74 + 1;
            v79 = v75 + 1;
            rc4_keyd = (struct rc4_key_st*)((char*)rc4_keyc - 1);
            if (!rc4_keyd)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v80 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v80 + v6);
            v81 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v81;
            *((_DWORD*)rc4_key + v6 + 2) = v80;
            *v78 = *v79 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v80 + v81) + 8);
            v82 = v78 + 1;
            v83 = v79 + 1;
            rc4_keye = (struct rc4_key_st*)((char*)rc4_keyd - 1);
            if (!rc4_keye)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v84 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v84 + v6);
            v85 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v85;
            *((_DWORD*)rc4_key + v6 + 2) = v84;
            *v82 = *v83 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v84 + v85) + 8);
            v86 = v82 + 1;
            v87 = v83 + 1;
            rc4_keyf = (struct rc4_key_st*)((char*)rc4_keye - 1);
            if (!rc4_keyf)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v88 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v88 + v6);
            v89 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v89;
            *((_DWORD*)rc4_key + v6 + 2) = v88;
            *v86 = *v87 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v88 + v89) + 8);
            v90 = v86 + 1;
            v91 = v87 + 1;
            rc4_keyg = (struct rc4_key_st*)((char*)rc4_keyf - 1);
            if (!rc4_keyg)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v92 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v92 + v6);
            v93 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v93;
            *((_DWORD*)rc4_key + v6 + 2) = v92;
            *v90 = *v91 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v92 + v93) + 8);
            v94 = v90 + 1;
            v95 = v91 + 1;
            rc4_keyh = (struct rc4_key_st*)((char*)rc4_keyg - 1);
            if (!rc4_keyh)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v96 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v96 + v6);
            v97 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v97;
            *((_DWORD*)rc4_key + v6 + 2) = v96;
            *v94 = *v95 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v96 + v97) + 8);
            v98 = v94 + 1;
            v99 = v95 + 1;
            rc4_keyi = (struct rc4_key_st*)((char*)rc4_keyh - 1);
            if (!rc4_keyi)
                break;
            v7 = (unsigned __int8)(v7 + 1);
            v100 = *((_DWORD*)rc4_key + v7 + 2);
            v6 = (unsigned __int8)(v100 + v6);
            v101 = *((_DWORD*)rc4_key + v6 + 2);
            *((_DWORD*)rc4_key + v7 + 2) = v101;
            *((_DWORD*)rc4_key + v6 + 2) = v100;
            *v98 = *v99 ^ *((_BYTE*)rc4_key + 4 * (unsigned __int8)(v100 + v101) + 8);
            v74 = v98 + 1;
            v75 = v99 + 1;
        }
    }
    *(_DWORD*)rc4_key = v7;
    *((_DWORD*)rc4_key + 1) = v6;
}

//----- (00001214) --------------------------------------------------------
BOOL CFileAuthClient::DecryptRC4(unsigned __int8* buf, unsigned int size)
{
    HCRYPTHASH v4; // [esp-14h] [ebp-430h]
    DWORD pdwDataLen; // [esp+0h] [ebp-41Ch] BYREF
    BYTE pbData[16]; // [esp+4h] [ebp-418h] BYREF
    char v11[1032]; // [esp+14h] [ebp-408h] BYREF

    pdwDataLen = 16;
    if (!CryptGetHashParam(hHash, 2u, pbData, &pdwDataLen, 0))
        return 0;

    RC4_set_key((struct rc4_key_st*)v11, 16, pbData);
    RC4((struct rc4_key_st*)v11, size, buf, buf);
    return 1;
}

// nfuncs=31 queued=8 decompiled=8 lumina nreq=0 worse=0 better=0
// ALL OK, 8 function(s) have been successfully decompiled

uchar* DecryptXOR(BYTE* szString, int StartPos, int iLen)
{
    //Every encrypted string starts with "01" byte
    //The key is actually a bit longer then the string (5 bytes)
    //String ends on byte "00" as normal strings also do
    if (!szString || szString[StartPos] != 1 || iLen < 5)
        return NULL;

    //Changes 2 bytes for more "security" lol
    DWORD dwKey = szString[StartPos+1];
    dwKey = dwKey + dwKey * 2;
    szString[StartPos+2] ^= (BYTE)dwKey + 0x65; //Byte 3

    dwKey = dwKey + dwKey * 2 + 3;
    szString[StartPos+3] ^= (BYTE)dwKey + 0x65; //Byte 4

    //Main decryption routine
    int i;
    for (i = 0; i < iLen - 5; i++)
    {
        dwKey++;

        dwKey = dwKey + dwKey * 2;
        BYTE bDL = dwKey;
        bDL += 0x65;
        szString[StartPos+i] = (bDL ^ (szString[StartPos + i + 4]));
    }

    //Overwrite the end with a string terminator (the key, no actual part of the string)
    //String size + 5
    for (int j = 0; j < 5; j++)
        szString[StartPos + i + j] = '\0';

    return (uchar*)szString;
}

void DecryptERLFiles(LPCSTR lpFilename, LPCSTR outputFilename) {
    HANDLE OpenHandle;
    HANDLE WriteHandle;
    DWORD fileSize;
    DWORD NumberOfBytesRead;
    uchar* buffer;
    OpenHandle = CreateFile(lpFilename, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);

    if (OpenHandle == (HANDLE)-1)
    {
        printf("fail open file\n");
        return;
    }
    fileSize = GetFileSize(OpenHandle, 0);

    if (fileSize == -1)
    {
        CloseHandle(OpenHandle);
        printf("fail open filesize\n");
        return;
    }

    buffer = (uchar*)malloc(fileSize);

    if (!buffer)
    {
        CloseHandle(OpenHandle);
        printf("fail allocate buffer\n");
        return;
    }

    ReadFile(OpenHandle, buffer, fileSize, &NumberOfBytesRead, 0);

    if (NumberOfBytesRead != fileSize)
    {
        CloseHandle(OpenHandle);
        printf("fail read size not same %d=%d\n", NumberOfBytesRead, fileSize);
        return;
    }

    int StartPos = -1;
    int TrimSize = -1;
    for (int i = 0; i < fileSize; i++) {
        if (StartPos == -1 && buffer[i] == 1)
            StartPos = i;
        else if (StartPos != -1 && buffer[i] == 1)
            TrimSize = i - StartPos;
        if (StartPos != -1 && TrimSize != -1) {
            buffer = (uchar*)DecryptXOR(buffer, StartPos, TrimSize);
            StartPos = -1;
            TrimSize = -1;
        }
    }

    WriteHandle = CreateFile(outputFilename, GENERIC_WRITE, 3u, 0, 2u, 0x80u, 0);
    if (WriteHandle == (HANDLE)-1)
    {
        printf("cannot write file\n");
        return;
    }
    else
    {
        WriteFile(WriteHandle, buffer, fileSize, (LPDWORD)&fileSize, 0);
        SetEndOfFile(WriteHandle);
        FlushFileBuffers(WriteHandle);
        CloseHandle(WriteHandle);
        if (buffer)
        {
            free(buffer);
            buffer = 0;
        }
        printf("finish good\n");
        return;
    }
}

int main()
{
    CFileAuthClient * test = new CFileAuthClient();

    test->Auth("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\AtlanticaNA.ini", 1);
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\AtlanticaNA.ini", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\AtlanticaNA.ini.dump.txt", (BYTE*)"ectGameMon");

    /*
    Keys dd \xC5\xF1\xF4\x35
            \x83\xA3\xA0\x23
            \x4E\x62\x6C\x2E
            \x89\x81\x88\x09
            \xCA\xF2\xF8\x3A
            \xD2\xD4\x16\xC6
            \x9C\x1D\x8D\x91
            \x64\x26\x46\x62
            \x39\x49\x71\x78
            \x1A\x0A\x12\x18
    */

    //DecryptERLFiles("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\output.test.txt");

    test->Auth("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", 1);
    /*
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.1.dump.txt", (BYTE*)"\xC5\xF1\xF4\x35");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.2.dump.txt", (BYTE*)"\x83\xA3\xA0\x23");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.3.dump.txt", (BYTE*)"\x4E\x62\x6C\x2E");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.4.dump.txt", (BYTE*)"\x89\x81\x88\x09");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.5.dump.txt", (BYTE*)"\xCA\xF2\xF8\x3A");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.6.dump.txt", (BYTE*)"\xD2\xD4\x16\xC6");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.7.dump.txt", (BYTE*)"\x9C\x1D\x8D\x91");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.8.dump.txt", (BYTE*)"\x64\x26\x46\x62");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.9.dump.txt", (BYTE*)"\x39\x49\x71\x78");
    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.10.dump.txt", (BYTE*)"\x1A\x0A\x12\x18");
    */

    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.new1.dump.txt", KEY2, dwPubKeyLen_Key2);


    test->Decrypt("C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl", "C:\\Users\\User\\Desktop\\Atlantica\\gguardfile\\ErlDecoder\\Debug\\0npgg.erl.new2.dump.txt", KEY3, dwPubKeyLen_Key3);


    
    std::cout << "Hello World!\n";
}